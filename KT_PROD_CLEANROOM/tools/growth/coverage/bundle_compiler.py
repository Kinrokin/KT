from __future__ import annotations

"""
Bundle Compiler (Phase 1)

Deterministically generates bundle_library.generated.json from ontology inputs:
  - ontology_domains.json         (list[str] of D:... IDs)
  - ontology_subdomains.json      (list[ { "domain": D:..., "subdomains": [S:...] } ])
  - ontology_ventures.json        (list[ { "venture_id": V:..., "domains": [D:...], "paradox_classes": [...], "reasoning_modes": [...] } ])

Goals:
  - Replace hand-written bundles with generated bundles derived from ontology
  - Enforce cross-domain pressure (bridge pairs)
  - Deterministic output (seeded)
  - Fail-closed on malformed inputs

This is tooling-only; it does not touch kernel or governance code.
"""

import argparse
import json
import random
from pathlib import Path
from typing import Any, Dict, List


class BundleCompilerError(RuntimeError):
    pass


def _read_json(path: Path) -> Any:
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
    except Exception as exc:
        raise BundleCompilerError(f"Failed to read {path.name}: {exc.__class__.__name__}") from exc
    return data


def _validate_domain_list(domains: Any) -> List[str]:
    if not isinstance(domains, list) or not all(isinstance(d, str) and d.startswith("D:") for d in domains):
        raise BundleCompilerError("ontology_domains.json must be list[str] of D:... IDs (fail-closed)")
    return domains


def _validate_subdomains(subs: Any) -> Dict[str, List[str]]:
    if not isinstance(subs, list):
        raise BundleCompilerError("ontology_subdomains.json must be list[...] (fail-closed)")
    out: Dict[str, List[str]] = {}
    for entry in subs:
        if not isinstance(entry, dict):
            raise BundleCompilerError("subdomain entry must be object (fail-closed)")
        dom = entry.get("domain")
        vals = entry.get("subdomains")
        if not isinstance(dom, str) or not dom.startswith("D:"):
            raise BundleCompilerError("subdomain entry missing domain D:... (fail-closed)")
        if not isinstance(vals, list) or not all(isinstance(s, str) and s.startswith("S:") for s in vals):
            raise BundleCompilerError("subdomains must be list[str] of S:... (fail-closed)")
        out[dom] = vals
    return out


def _validate_ventures(v: Any) -> List[Dict[str, Any]]:
    if not isinstance(v, list):
        raise BundleCompilerError("ontology_ventures.json must be list[...] (fail-closed)")
    cleaned: List[Dict[str, Any]] = []
    for entry in v:
        if not isinstance(entry, dict):
            raise BundleCompilerError("venture entry must be object (fail-closed)")
        vid = entry.get("venture_id")
        doms = entry.get("domains") or []
        paradox = entry.get("paradox_classes") or []
        modes = entry.get("reasoning_modes") or []
        if not isinstance(vid, str) or not vid.startswith("V:"):
            raise BundleCompilerError("venture_id must be V:... (fail-closed)")
        if not isinstance(doms, list) or not all(isinstance(d, str) and d.startswith("D:") for d in doms):
            raise BundleCompilerError("venture domains must be list[str] of D:... (fail-closed)")
        if not isinstance(paradox, list) or not all(isinstance(p, str) and p.startswith("P:") for p in paradox):
            raise BundleCompilerError("paradox_classes must be list[str] of P:... (fail-closed)")
        if not isinstance(modes, list) or not all(isinstance(m, str) and m.startswith("R:") for m in modes):
            raise BundleCompilerError("reasoning_modes must be list[str] of R:... (fail-closed)")
        cleaned.append(
            {
                "venture_id": vid,
                "domains": doms,
                "paradox_classes": paradox,
                "reasoning_modes": modes,
            }
        )
    return cleaned


def _bridge_pairs(subdomains: List[str], rng: random.Random, count: int) -> List[List[str]]:
    pairs: List[List[str]] = []
    if len(subdomains) < 2:
        return pairs
    subs = list(subdomains)
    rng.shuffle(subs)
    for i in range(0, min(count * 2, len(subs) - 1), 2):
        pairs.append([subs[i], subs[i + 1]])
    return pairs


def _make_bundle(
    *,
    bundle_id: str,
    domains: List[str],
    subdomains: List[str],
    ventures: List[str],
    reasoning_modes: List[str],
    paradox_classes: List[str],
    min_bridge_edges: int,
    bridge_pairs: List[List[str]],
) -> Dict[str, Any]:
    return {
        "bundle_id": bundle_id,
        "description": "Generated by bundle_compiler.py",
        "required_tags": {
            "domains": domains,
            "subdomains": subdomains,
            "microdomains": [],
            "ventures": ventures,
            "reasoning_modes": reasoning_modes,
            "modalities": [],
            "tools": [],
            "paradox_classes": paradox_classes,
        },
        "bridge_pairs": bridge_pairs,
        "min_bridge_edges": min_bridge_edges,
    }


def generate_bundles(
    *,
    domains: List[str],
    subdomains_by_domain: Dict[str, List[str]],
    ventures: List[Dict[str, Any]],
    seed: int,
) -> List[Dict[str, Any]]:
    rng = random.Random(seed)
    bundles: List[Dict[str, Any]] = []

    for v in ventures:
        vid = v["venture_id"]
        v_doms = v["domains"]
        paradoxes = v["paradox_classes"]
        modes = v["reasoning_modes"] or ["R:COT"]

        # CORE bundle: at least two domains if available
        core_domains = v_doms[:2] if len(v_doms) >= 2 else (v_doms + domains[: max(0, 2 - len(v_doms))])
        core_subs: List[str] = []
        for d in core_domains:
            core_subs.extend(subdomains_by_domain.get(d, [])[:2])
        core_bridge = _bridge_pairs(core_subs, rng, count=2)
        bundles.append(
            _make_bundle(
                bundle_id=f"BUNDLE:{vid}.CORE",
                domains=core_domains,
                subdomains=core_subs[:4],
                ventures=[vid],
                reasoning_modes=modes[:2],
                paradox_classes=paradoxes[:1],
                min_bridge_edges=10,
                bridge_pairs=core_bridge,
            )
        )

        # EDGE bundle: push paradox if present, otherwise cross-domain depth
        edge_domains = list(set(v_doms + rng.sample(domains, k=min(2, len(domains)))))
        edge_subs: List[str] = []
        for d in edge_domains:
            edge_subs.extend(subdomains_by_domain.get(d, [])[:1])
        edge_bridge = _bridge_pairs(edge_subs, rng, count=3)
        bundles.append(
            _make_bundle(
                bundle_id=f"BUNDLE:{vid}.EDGE",
                domains=edge_domains[:3],
                subdomains=edge_subs[:6],
                ventures=[vid],
                reasoning_modes=modes[:2],
                paradox_classes=paradoxes[:2],
                min_bridge_edges=12,
                bridge_pairs=edge_bridge,
            )
        )

        # ADVERSARIAL bundle: enforce cross-domain contradiction pressure
        adv_domains = list(set(edge_domains + rng.sample(domains, k=min(3, len(domains)))))
        adv_subs: List[str] = []
        for d in adv_domains:
            adv_subs.extend(subdomains_by_domain.get(d, [])[:2])
        adv_bridge = _bridge_pairs(adv_subs, rng, count=4)
        bundles.append(
            _make_bundle(
                bundle_id=f"BUNDLE:{vid}.ADVERSARIAL",
                domains=adv_domains[:4],
                subdomains=adv_subs[:8],
                ventures=[vid],
                reasoning_modes=["R:TOT"] + modes[:1],
                paradox_classes=paradoxes[:3] or ["P:BELNAP.BOTH"],
                min_bridge_edges=16,
                bridge_pairs=adv_bridge,
            )
        )

    return bundles


def compile_bundles(
    *,
    domains_path: Path,
    subdomains_path: Path,
    ventures_path: Path,
    seed: int,
    out_path: Path,
) -> Path:
    domains = _validate_domain_list(_read_json(domains_path))
    subdomains_by_domain = _validate_subdomains(_read_json(subdomains_path))
    ventures = _validate_ventures(_read_json(ventures_path))

    bundles = generate_bundles(
        domains=domains,
        subdomains_by_domain=subdomains_by_domain,
        ventures=ventures,
        seed=seed,
    )

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(json.dumps(bundles, sort_keys=True, indent=2, ensure_ascii=True) + "\n", encoding="utf-8")
    return out_path


def _parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Bundle compiler (auto-generates bundle library from ontology).")
    p.add_argument("--domains", required=True, help="Path to ontology_domains.json")
    p.add_argument("--subdomains", required=True, help="Path to ontology_subdomains.json")
    p.add_argument("--ventures", required=True, help="Path to ontology_ventures.json")
    p.add_argument("--out", required=True, help="Output path for bundle_library.generated.json")
    p.add_argument("--seed", type=int, default=0, help="Deterministic seed (default: 0)")
    return p.parse_args()


def main() -> int:
    args = _parse_args()
    out = compile_bundles(
        domains_path=Path(args.domains).resolve(),
        subdomains_path=Path(args.subdomains).resolve(),
        ventures_path=Path(args.ventures).resolve(),
        seed=int(args.seed),
        out_path=Path(args.out).resolve(),
    )
    print(json.dumps({"out": out.as_posix()}, ensure_ascii=True))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
